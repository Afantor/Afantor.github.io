

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Quick reference for the nRF52832 &mdash; MicroPython 1.10 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../static/favicon.ico"/>
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../static/customstyle.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="General information about the nRF52832 port" href="general.html" />
    <link rel="prev" title="6. Reset and boot modes" href="../wipy/tutorial/reset.html" /> 

  
  <script src="../static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> MicroPython
          

          
          </a>

          
            
            
              <div class="version">
                1.10
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../library/index.html">MicroPython libraries</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/index.html">The MicroPython language</a></li>
<li class="toctree-l1"><a class="reference internal" href="../genrst/index.html">MicroPython differences from CPython</a></li>
<li class="toctree-l1"><a class="reference internal" href="../develop/index.html">Developing and building MicroPython</a></li>
<li class="toctree-l1"><a class="reference internal" href="../license.html">MicroPython license information</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pyboard/quickref.html">Quick reference for the pyboard</a></li>
<li class="toctree-l1"><a class="reference internal" href="../esp8266/quickref.html">Quick reference for the ESP8266</a></li>
<li class="toctree-l1"><a class="reference internal" href="../esp32/quickref.html">Quick reference for the ESP32</a></li>
<li class="toctree-l1"><a class="reference internal" href="../wipy/quickref.html">Quick reference for the WiPy</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Quick reference for the nRF52832</a><ul>
<li class="toctree-l2"><a class="reference internal" href="general.html">General information about the nRF52832 port</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial/intro.html">Getting started with MicroPython on the nRF52832</a></li>
<li class="toctree-l2"><a class="reference internal" href="#installing-micropython">Installing MicroPython</a></li>
<li class="toctree-l2"><a class="reference internal" href="#general-board-control">General board control</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-machine">Machine</a></li>
<li class="toctree-l2"><a class="reference internal" href="#delay-and-timing">Delay and timing</a></li>
<li class="toctree-l2"><a class="reference internal" href="#timers">Timers</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pins-and-gpio">Pins and GPIO</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pwm-pulse-width-modulation">PWM (pulse width modulation)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#adc-analog-to-digital-conversion">ADC (analog to digital conversion)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#software-spi-bus">Software SPI bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hardware-spi-bus">Hardware SPI bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="#i2c-bus">I2C bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="#real-time-clock-counter-rtcounter">Real time clock Counter (RTCounter)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#deep-sleep-mode">Deep-sleep mode</a></li>
<li class="toctree-l2"><a class="reference internal" href="#temp">Temp</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-machine.UART">UART</a></li>
<li class="toctree-l2"><a class="reference internal" href="#example">Example</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">MicroPython</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Quick reference for the nRF52832</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../sources/nrf52/quickref.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="quick-reference-for-the-nrf52832">
<span id="nrf52832-quickref"></span><h1>Quick reference for the nRF52832<a class="headerlink" href="#quick-reference-for-the-nrf52832" title="Permalink to this headline">¶</a></h1>
<a class="reference internal image-reference" href="../images/nRF52.JPG"><img alt="nRF52832-Bluefruit52 board" src="../images/nRF52.JPG" style="width: 640px;" /></a>
<p>The Afantor nRF52832 Bluefruit52 Development Board (image attribution: Afantor).</p>
<p>Below is a quick reference for nRF52832-based boards.  If it is your first time
working with this board it may be useful to get an overview of the microcontroller:</p>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="general.html">General information about the nRF52832 port</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial/intro.html">Getting started with MicroPython on the nRF52832</a></li>
</ul>
</div>
<div class="section" id="installing-micropython">
<h2>Installing MicroPython<a class="headerlink" href="#installing-micropython" title="Permalink to this headline">¶</a></h2>
<p>See the corresponding section of tutorial: <a class="reference internal" href="tutorial/intro.html#nrf52-intro"><span class="std std-ref">Getting started with MicroPython on the nRF52832</span></a>. It also includes
a troubleshooting subsection.</p>
</div>
<div class="section" id="general-board-control">
<h2>General board control<a class="headerlink" href="#general-board-control" title="Permalink to this headline">¶</a></h2>
<p>The MicroPython REPL is on UART1 (GPIO10.06=TX, GPIO0.08=RX) at baudrate 115200.
Tab-completion is useful to find out what methods an object has.
Paste mode (ctrl-E) is useful to paste a large slab of Python code into
the REPL.</p>
</div>
<div class="section" id="module-machine">
<span id="machine"></span><h2>Machine<a class="headerlink" href="#module-machine" title="Permalink to this headline">¶</a></h2>
<p>The machine module contains specific functions related to the nRF52832
hardware. Most functions in this module allow to achieve direct and
unrestricted access to and control of hardware blocks on a system (like CPU,
timers, buses, etc.). Used incorrectly, this can lead to malfunction, lockups,
crashes of your board, and in extreme cases, hardware damage.</p>
<p>Functions</p>
<dl class="method">
<dt id="machine.machine.reset">
<code class="descclassname">machine.</code><code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#machine.machine.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets the device in a manner similar to pushing the external RESET button.</p>
</dd></dl>

<dl class="method">
<dt id="machine.machine.disable_irq">
<code class="descclassname">machine.</code><code class="descname">disable_irq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#machine.machine.disable_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable interrupt requests. Returns the previous IRQ state which should be
considered an opaque value. This return value should be passed to the
<a class="reference internal" href="../library/machine.html#machine.enable_irq" title="machine.enable_irq"><code class="xref py py-func docutils literal notranslate"><span class="pre">machine.enable_irq()</span></code></a> function to restore interrupts to their
original state, before <a class="reference internal" href="../library/machine.html#machine.disable_irq" title="machine.disable_irq"><code class="xref py py-func docutils literal notranslate"><span class="pre">machine.disable_irq()</span></code></a> was called.</p>
</dd></dl>

<dl class="method">
<dt id="machine.machine.enable_irq">
<code class="descclassname">machine.</code><code class="descname">enable_irq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#machine.machine.enable_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-enable interrupt requests. The <em>state</em> parameter should be the value
that was returned from the most recent call to the
<a class="reference internal" href="../library/machine.html#machine.disable_irq" title="machine.disable_irq"><code class="xref py py-func docutils literal notranslate"><span class="pre">machine.disable_irq()</span></code></a> function.</p>
</dd></dl>

<dl class="method">
<dt id="machine.machine.deepsleep">
<code class="descclassname">machine.</code><code class="descname">deepsleep</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#machine.machine.deepsleep" title="Permalink to this definition">¶</a></dt>
<dd><p>in to deepsleep mode.</p>
</dd></dl>

<dl class="method">
<dt id="machine.machine.info">
<code class="descclassname">machine.</code><code class="descname">info</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#machine.machine.info" title="Permalink to this definition">¶</a></dt>
<dd><p>Return machine some information.</p>
</dd></dl>

<dl class="method">
<dt id="machine.machine.lightsleep">
<code class="descclassname">machine.</code><code class="descname">lightsleep</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#machine.machine.lightsleep" title="Permalink to this definition">¶</a></dt>
<dd><p>in to lightsleep mode.</p>
</dd></dl>

<dl class="method">
<dt id="machine.machine.reset_cause">
<code class="descclassname">machine.</code><code class="descname">reset_cause</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#machine.machine.reset_cause" title="Permalink to this definition">¶</a></dt>
<dd><p>Return machine reset cause countor.</p>
</dd></dl>

<dl class="method">
<dt id="machine.machine.sleep">
<code class="descclassname">machine.</code><code class="descname">sleep</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#machine.machine.sleep" title="Permalink to this definition">¶</a></dt>
<dd><p>in to lightsleep mode.</p>
</dd></dl>

<dl class="method">
<dt id="machine.machine.soft_reset">
<code class="descclassname">machine.</code><code class="descname">soft_reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#machine.machine.soft_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets the device in a manner similar to pushing the external RESET button.</p>
</dd></dl>

<p>The <a class="reference internal" href="#module-machine" title="machine"><code class="xref py py-mod docutils literal notranslate"><span class="pre">machine</span></code></a> module:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">machine</span>

<span class="n">machine</span><span class="o">.</span><span class="n">info</span><span class="p">()</span>          <span class="c1"># Return machine some information</span>
<span class="n">machine</span><span class="o">.</span><span class="n">enable_irq</span><span class="p">()</span>    <span class="c1"># Re-enable interrupt requests.</span>
<span class="n">machine</span><span class="o">.</span><span class="n">disable_irq</span><span class="p">()</span>   <span class="c1"># disable interrupt requests.</span>
<span class="n">machine</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>         <span class="c1"># Reset machine system</span>
<span class="n">machine</span><span class="o">.</span><span class="n">soft_reset</span><span class="p">()</span>    <span class="c1"># soft_reset machine system</span>
</pre></div>
</div>
<p>Note that the temperature sensor in the nRF52832 will typically read higher than
ambient due to the IC getting warm while it runs.  This effect can be minimised
by reading the temperature sensor immediately after waking up from sleep.</p>
</div>
<div class="section" id="delay-and-timing">
<h2>Delay and timing<a class="headerlink" href="#delay-and-timing" title="Permalink to this headline">¶</a></h2>
<p>Use the <a class="reference internal" href="../library/utime.html#module-utime" title="utime: time related functions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">time</span></code></a> module:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>

<span class="n">time</span><span class="o">.</span><span class="n">sleep_ms</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span>      <span class="c1"># sleep for 500 milliseconds</span>
<span class="n">time</span><span class="o">.</span><span class="n">sleep_us</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>       <span class="c1"># sleep for 10 microseconds</span>
</pre></div>
</div>
</div>
<div class="section" id="timers">
<h2>Timers<a class="headerlink" href="#timers" title="Permalink to this headline">¶</a></h2>
<p>Hardware timers are supported. Use the <a class="reference internal" href="../library/machine.Timer.html#machine-timer"><span class="std std-ref">machine.Timer</span></a> class
with timer ID of -1:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">machine</span> <span class="k">import</span> <span class="n">Timer</span>

<span class="n">tim</span> <span class="o">=</span> <span class="n">Timer</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;tick&quot;</span><span class="p">))</span>
<span class="n">tim</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">tim</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">tim</span><span class="o">.</span><span class="n">period</span><span class="p">()</span>
<span class="n">tim</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
<span class="n">tim</span><span class="o">.</span><span class="n">deinit</span><span class="p">()</span>
</pre></div>
</div>
<p>Constants</p>
<dl class="data">
<dt id="machine.Timer.ONESHOT">
<code class="descclassname">Timer.</code><code class="descname">ONESHOT</code><a class="headerlink" href="#machine.Timer.ONESHOT" title="Permalink to this definition">¶</a></dt>
<dt id="machine.Timer.PERIODIC">
<code class="descclassname">Timer.</code><code class="descname">PERIODIC</code><a class="headerlink" href="#machine.Timer.PERIODIC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="pins-and-gpio">
<h2>Pins and GPIO<a class="headerlink" href="#pins-and-gpio" title="Permalink to this headline">¶</a></h2>
<p>Use the <a class="reference internal" href="../library/machine.Pin.html#machine-pin"><span class="std std-ref">machine.Pin</span></a> class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">machine</span> <span class="k">import</span> <span class="n">Pin</span>

<span class="n">p2</span> <span class="o">=</span> <span class="n">Pin</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">Pin</span><span class="o">.</span><span class="n">OUT</span><span class="p">)</span>    <span class="c1"># create output pin on GPIO0.02</span>
<span class="n">p2</span><span class="o">.</span><span class="n">on</span><span class="p">()</span>                 <span class="c1"># set pin to &quot;on&quot; (high) level</span>
<span class="n">p2</span><span class="o">.</span><span class="n">off</span><span class="p">()</span>                <span class="c1"># set pin to &quot;off&quot; (low) level</span>
<span class="n">p2</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>             <span class="c1"># set pin to on/high</span>

<span class="n">p3</span> <span class="o">=</span> <span class="n">Pin</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">Pin</span><span class="o">.</span><span class="n">IN</span><span class="p">)</span>     <span class="c1"># create input pin on GPIO0.03</span>
<span class="nb">print</span><span class="p">(</span><span class="n">p3</span><span class="o">.</span><span class="n">value</span><span class="p">())</span>       <span class="c1"># get value, 0 or 1</span>

<span class="n">p4</span> <span class="o">=</span> <span class="n">Pin</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">Pin</span><span class="o">.</span><span class="n">IN</span><span class="p">,</span> <span class="n">Pin</span><span class="o">.</span><span class="n">PULL_UP</span><span class="p">)</span> <span class="c1"># enable internal pull-up resistor</span>
<span class="n">p5</span> <span class="o">=</span> <span class="n">Pin</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">Pin</span><span class="o">.</span><span class="n">OUT</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># set pin high on creation</span>
</pre></div>
</div>
<p>Constants</p>
<dl class="data">
<dt id="machine.Pin.IN">
<code class="descclassname">Pin.</code><code class="descname">IN</code><a class="headerlink" href="#machine.Pin.IN" title="Permalink to this definition">¶</a></dt>
<dt id="machine.Pin.OUT">
<code class="descclassname">Pin.</code><code class="descname">OUT</code><a class="headerlink" href="#machine.Pin.OUT" title="Permalink to this definition">¶</a></dt>
<dt id="machine.Pin.PULL_UP">
<code class="descclassname">Pin.</code><code class="descname">PULL_UP</code><a class="headerlink" href="#machine.Pin.PULL_UP" title="Permalink to this definition">¶</a></dt>
<dt id="machine.Pin.PULL_DOWN">
<code class="descclassname">Pin.</code><code class="descname">PULL_DOWN</code><a class="headerlink" href="#machine.Pin.PULL_DOWN" title="Permalink to this definition">¶</a></dt>
<dt id="machine.Pin.PULL_DISABLED">
<code class="descclassname">Pin.</code><code class="descname">PULL_DISABLED</code><a class="headerlink" href="#machine.Pin.PULL_DISABLED" title="Permalink to this definition">¶</a></dt>
<dt id="machine.Pin.IRQ_FALLING">
<code class="descclassname">Pin.</code><code class="descname">IRQ_FALLING</code><a class="headerlink" href="#machine.Pin.IRQ_FALLING" title="Permalink to this definition">¶</a></dt>
<dt id="machine.Pin.IRQ_RISING">
<code class="descclassname">Pin.</code><code class="descname">IRQ_RISING</code><a class="headerlink" href="#machine.Pin.IRQ_RISING" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Available Pins are from the following ranges (inclusive): 2-20, 25-31.
These correspond to the actual GPIO pin numbers of nRF52832 chip.  Note that many
end-user boards use their own adhoc pin numbering (marked e.g. D0, D1, …).
For mapping between board logical pins and physical chip pins consult your board
documentation.</p>
<p>Notes:</p>
<ul class="simple">
<li>Pins 6 and 8 are REPL UART TX and RX respectively</li>
<li>Pins 7, 15, 16, and 27 are used for connecting the lcd screen driver,
and are not recommended for other uses</li>
<li>Pins 11 and 18 are used for connecting the button, and it have been pull up 10k to 3.3v</li>
<li>Pins 17 and 19 are used for connecting the led.</li>
</ul>
</div>
<div class="section" id="pwm-pulse-width-modulation">
<h2>PWM (pulse width modulation)<a class="headerlink" href="#pwm-pulse-width-modulation" title="Permalink to this headline">¶</a></h2>
<p>PWM can be enabled on all output-enabled pins. The base frequency can
range from 1Hz to 16MHz but there is a tradeoff; as the base frequency
<em>increases</em> the duty resolution <em>decreases</em>.</p>
<p>Use the <code class="docutils literal notranslate"><span class="pre">machine.PWM</span></code> class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">machine</span> <span class="k">import</span> <span class="n">Pin</span><span class="p">,</span> <span class="n">PWM</span>

<span class="n">pwm0</span> <span class="o">=</span> <span class="n">PWM</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">pin</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="n">Pin</span><span class="o">.</span><span class="n">OUT</span><span class="p">),</span><span class="n">duty</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span><span class="n">period</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>   <span class="c1"># create PWM object from a pin,and set duty period.</span>
<span class="n">pwm0</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>             <span class="c1"># get current frequency</span>
<span class="n">pwm0</span><span class="o">.</span><span class="n">freq</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>         <span class="c1"># set frequency</span>
<span class="n">pwm0</span><span class="o">.</span><span class="n">duty</span><span class="p">()</span>             <span class="c1"># get current duty cycle</span>
<span class="n">pwm0</span><span class="o">.</span><span class="n">duty</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span>          <span class="c1"># set duty cycle</span>
<span class="n">pwm0</span><span class="o">.</span><span class="n">period</span><span class="p">()</span>           <span class="c1">#</span>
<span class="n">pwm0</span><span class="o">.</span><span class="n">deinit</span><span class="p">()</span>           <span class="c1"># turn off PWM on the pin</span>
</pre></div>
</div>
<p>Constants</p>
<dl class="data">
<dt id="machine.PWM.FREQ_16MHZ">
<code class="descclassname">PWM.</code><code class="descname">FREQ_16MHZ</code><a class="headerlink" href="#machine.PWM.FREQ_16MHZ" title="Permalink to this definition">¶</a></dt>
<dt id="machine.PWM.FREQ_8MHZ">
<code class="descclassname">PWM.</code><code class="descname">FREQ_8MHZ</code><a class="headerlink" href="#machine.PWM.FREQ_8MHZ" title="Permalink to this definition">¶</a></dt>
<dt id="machine.PWM.FREQ_4MHZ">
<code class="descclassname">PWM.</code><code class="descname">FREQ_4MHZ</code><a class="headerlink" href="#machine.PWM.FREQ_4MHZ" title="Permalink to this definition">¶</a></dt>
<dt id="machine.PWM.FREQ_2MHZ">
<code class="descclassname">PWM.</code><code class="descname">FREQ_2MHZ</code><a class="headerlink" href="#machine.PWM.FREQ_2MHZ" title="Permalink to this definition">¶</a></dt>
<dt id="machine.PWM.FREQ_1MHZ">
<code class="descclassname">PWM.</code><code class="descname">FREQ_1MHZ</code><a class="headerlink" href="#machine.PWM.FREQ_1MHZ" title="Permalink to this definition">¶</a></dt>
<dt id="machine.PWM.FREQ_500KHZ">
<code class="descclassname">PWM.</code><code class="descname">FREQ_500KHZ</code><a class="headerlink" href="#machine.PWM.FREQ_500KHZ" title="Permalink to this definition">¶</a></dt>
<dt id="machine.PWM.FREQ_250KHZ">
<code class="descclassname">PWM.</code><code class="descname">FREQ_250KHZ</code><a class="headerlink" href="#machine.PWM.FREQ_250KHZ" title="Permalink to this definition">¶</a></dt>
<dt id="machine.PWM.FREQ_125KHZ">
<code class="descclassname">PWM.</code><code class="descname">FREQ_125KHZ</code><a class="headerlink" href="#machine.PWM.FREQ_125KHZ" title="Permalink to this definition">¶</a></dt>
<dt id="machine.PWM.MODE_LOW_HIGH">
<code class="descclassname">PWM.</code><code class="descname">MODE_LOW_HIGH</code><a class="headerlink" href="#machine.PWM.MODE_LOW_HIGH" title="Permalink to this definition">¶</a></dt>
<dt id="machine.PWM.MODE_HIGH_LOW">
<code class="descclassname">PWM.</code><code class="descname">MODE_HIGH_LOW</code><a class="headerlink" href="#machine.PWM.MODE_HIGH_LOW" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Available Pins are from the following ranges (inclusive): 2-5, 11-20, 25-31.</p>
</div>
<div class="section" id="adc-analog-to-digital-conversion">
<h2>ADC (analog to digital conversion)<a class="headerlink" href="#adc-analog-to-digital-conversion" title="Permalink to this headline">¶</a></h2>
<p>On the nRF52832 ADC functionality is available 8 channels（0~7）. Note that, when
using the default configuration, input voltages on the ADC pin must be between
0.0v and 3.3v.  Attenuation must be applied in order to increase this usable voltage range.</p>
<p>Use the <a class="reference internal" href="../library/machine.ADC.html#machine-adc"><span class="std std-ref">machine.ADC</span></a> class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">machine</span> <span class="k">import</span> <span class="n">ADC</span>

<span class="n">adc3</span> <span class="o">=</span> <span class="n">ADC</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>                <span class="c1"># create ADC object on ADC pin</span>
<span class="n">adc3</span><span class="o">.</span><span class="n">value</span><span class="p">()</span>                 <span class="c1"># read value, 0-255 across voltage range 0.0v - 3.3v</span>

<span class="n">adc3</span><span class="o">.</span><span class="n">battery_level</span><span class="p">()</span>        <span class="c1"># read battery value.</span>
</pre></div>
</div>
</div>
<div class="section" id="software-spi-bus">
<h2>Software SPI bus<a class="headerlink" href="#software-spi-bus" title="Permalink to this headline">¶</a></h2>
<p>There are two SPI drivers. One is implemented in software (bit-banging)
and works on all pins, and is accessed via the <a class="reference internal" href="../library/machine.SPI.html#machine-spi"><span class="std std-ref">machine.SPI</span></a>
class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">machine</span> <span class="k">import</span> <span class="n">Pin</span><span class="p">,</span> <span class="n">SPI</span>

<span class="c1"># construct an SPI bus on the given pins</span>
<span class="c1"># polarity is the idle state of SCK</span>
<span class="c1"># phase=0 means sample on the first edge of SCK, phase=1 means the second</span>
<span class="n">spi</span> <span class="o">=</span> <span class="n">SPI</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">baudrate</span><span class="o">=</span><span class="mi">100000</span><span class="p">,</span> <span class="n">polarity</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">phase</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sck</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">mosi</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">13</span><span class="p">),</span> <span class="n">miso</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">14</span><span class="p">))</span>

<span class="n">spi</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">baudrate</span><span class="o">=</span><span class="mi">200000</span><span class="p">)</span> <span class="c1"># set the baudrate</span>

<span class="n">spi</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>            <span class="c1"># read 10 bytes on MISO</span>
<span class="n">spi</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">)</span>      <span class="c1"># read 10 bytes while outputing 0xff on MOSI</span>

<span class="n">buf</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>     <span class="c1"># create a buffer</span>
<span class="n">spi</span><span class="o">.</span><span class="n">readinto</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>       <span class="c1"># read into the given buffer (reads 50 bytes in this case)</span>
<span class="n">spi</span><span class="o">.</span><span class="n">readinto</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">)</span> <span class="c1"># read into the given buffer and output 0xff on MOSI</span>

<span class="n">spi</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;12345&#39;</span><span class="p">)</span>     <span class="c1"># write 5 bytes on MOSI</span>

<span class="n">buf</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>      <span class="c1"># create a buffer</span>
<span class="n">spi</span><span class="o">.</span><span class="n">write_readinto</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;1234&#39;</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span> <span class="c1"># write to MOSI and read from MISO into the buffer</span>
<span class="n">spi</span><span class="o">.</span><span class="n">write_readinto</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span> <span class="c1"># write buf to MOSI and read MISO back into buf</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Currently <em>all</em> of <code class="docutils literal notranslate"><span class="pre">sck</span></code>, <code class="docutils literal notranslate"><span class="pre">mosi</span></code> and <code class="docutils literal notranslate"><span class="pre">miso</span></code> <em>must</em> be specified when
initialising Software SPI.</p>
</div>
<p>Functions</p>
<dl class="method">
<dt id="machine.init">
<code class="descclassname">machine.</code><code class="descname">init</code><span class="sig-paren">(</span><em>baudrate=1000000</em>, <em>bits=8</em>, <em>mode=0</em>, <em>sclk=pin12</em>, <em>mosi=pin13</em>, <em>miso=pin14</em><span class="sig-paren">)</span><a class="headerlink" href="#machine.init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize SPI communication with the specified parameters on the
specified <code class="docutils literal notranslate"><span class="pre">pins</span></code>. Note that for correct communication, the parameters
have to be the same on both communicating devices.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">baudrate</span></code> defines the speed of communication.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">bits</span></code> defines the size of bytes being transmitted. Currently only
<code class="docutils literal notranslate"><span class="pre">bits=8</span></code> is supported. However, this may change in the future.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">mode</span></code> determines the combination of clock polarity and phase
according to the following convention, with polarity as the high order bit
and phase as the low order bit:</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="41%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">SPI Mode</th>
<th class="head">Polarity (CPOL)</th>
<th class="head">Phase (CPHA)</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="row-even"><td>2</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>Polarity (aka CPOL) 0 means that the clock is at logic value 0 when idle
and goes high (logic value 1) when active; polarity 1 means the clock is
at logic value 1 when idle and goes low (logic value 0) when active. Phase
(aka CPHA) 0 means that data is sampled on the leading edge of the clock,
and 1 means on the trailing edge
(viz. <a class="reference external" href="https://en.wikipedia.org/wiki/Signal_edge">https://en.wikipedia.org/wiki/Signal_edge</a>).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">sclk</span></code>, <code class="docutils literal notranslate"><span class="pre">mosi</span></code> and <code class="docutils literal notranslate"><span class="pre">miso</span></code> arguments specify the pins to use for
each type of signal.</p>
</dd></dl>

<dl class="method">
<dt id="machine.spi.read">
<code class="descclassname">spi.</code><code class="descname">read</code><span class="sig-paren">(</span><em>nbytes</em><span class="sig-paren">)</span><a class="headerlink" href="#machine.spi.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Read at most <code class="docutils literal notranslate"><span class="pre">nbytes</span></code>. Returns what was read.</p>
</dd></dl>

<dl class="method">
<dt id="machine.spi.write">
<code class="descclassname">spi.</code><code class="descname">write</code><span class="sig-paren">(</span><em>buffer</em><span class="sig-paren">)</span><a class="headerlink" href="#machine.spi.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the <code class="docutils literal notranslate"><span class="pre">buffer</span></code> of bytes to the bus.</p>
</dd></dl>

<dl class="method">
<dt id="machine.spi.write_readinto">
<code class="descclassname">spi.</code><code class="descname">write_readinto</code><span class="sig-paren">(</span><em>out</em>, <em>in</em><span class="sig-paren">)</span><a class="headerlink" href="#machine.spi.write_readinto" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the <code class="docutils literal notranslate"><span class="pre">out</span></code> buffer to the bus and read any response into the <code class="docutils literal notranslate"><span class="pre">in</span></code>
buffer. The length of the buffers should be the same. The buffers can be
the same object.</p>
</dd></dl>

</div>
<div class="section" id="hardware-spi-bus">
<h2>Hardware SPI bus<a class="headerlink" href="#hardware-spi-bus" title="Permalink to this headline">¶</a></h2>
<p>There is one hardware SPI channels that allow faster transmission rates,
but are only supported on a subset of pins.</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"></th>
<th class="head">SPI (id=0)</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>sck</td>
<td>12</td>
</tr>
<tr class="row-odd"><td>mosi</td>
<td>13</td>
</tr>
<tr class="row-even"><td>miso</td>
<td>14</td>
</tr>
</tbody>
</table>
<p>Hardware SPI has the same methods as Software SPI above:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">machine</span> <span class="k">import</span> <span class="n">Pin</span><span class="p">,</span> <span class="n">SPI</span>

<span class="n">hspi</span> <span class="o">=</span> <span class="n">SPI</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">baudrate</span><span class="o">=</span><span class="mi">10000000</span><span class="p">,</span> <span class="n">polarity</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">phase</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bits</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">firstbit</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">sck</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">mosi</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">13</span><span class="p">),</span> <span class="n">miso</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">14</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="i2c-bus">
<h2>I2C bus<a class="headerlink" href="#i2c-bus" title="Permalink to this headline">¶</a></h2>
<p>The I2C driver is implemented in software and works on all pins,
and is accessed via the <a class="reference internal" href="../library/machine.I2C.html#machine-i2c"><span class="std std-ref">machine.I2C</span></a> class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">machine</span> <span class="k">import</span> <span class="n">Pin</span><span class="p">,</span> <span class="n">I2C</span>

<span class="c1"># construct an I2C bus</span>
<span class="n">i2c</span> <span class="o">=</span> <span class="n">I2C</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">scl</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">26</span><span class="p">),</span> <span class="n">sda</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">25</span><span class="p">))</span>

<span class="n">i2c</span><span class="o">.</span><span class="n">scan</span><span class="p">()</span>

<span class="n">i2c</span><span class="o">.</span><span class="n">readfrom</span><span class="p">(</span><span class="mh">0x3a</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>   <span class="c1"># read 4 bytes from slave device with address 0x3a</span>
<span class="n">i2c</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="mh">0x3a</span><span class="p">,</span> <span class="s1">&#39;12&#39;</span><span class="p">)</span> <span class="c1"># write &#39;12&#39; to slave device with address 0x3a</span>

<span class="n">buf</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>     <span class="c1"># create a buffer with 10 bytes</span>
<span class="n">i2c</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="mh">0x3a</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span>  <span class="c1"># write the given buffer to the slave</span>
</pre></div>
</div>
<p>Connecting</p>
<p>You should connect the device’s <code class="docutils literal notranslate"><span class="pre">SCL</span></code> pin to Bluefruit52 pin 26, and the
device’s <code class="docutils literal notranslate"><span class="pre">SDA</span></code> pin to Bluefruit52 pin 25. You also must connect the device’s
ground to the Bluefruit52 ground (pin <code class="docutils literal notranslate"><span class="pre">GND</span></code>). You may need to power the device
using an external power supply or the Bluefruit52.</p>
<p>There are internal pull-up resistors on the I²C lines of the board, but with
particularly long wires or large number of devices you may need to add
additional pull-up resistors, to ensure noise-free communication.</p>
</div>
<div class="section" id="real-time-clock-counter-rtcounter">
<h2>Real time clock Counter (RTCounter)<a class="headerlink" href="#real-time-clock-counter-rtcounter" title="Permalink to this headline">¶</a></h2>
<p>See <span class="xref std std-ref">machine.RTCounter</span></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">machine</span> <span class="k">import</span> <span class="n">RTCounter</span>

<span class="n">rtcount</span> <span class="o">=</span> <span class="n">RTCounter</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;tick&quot;</span><span class="p">))</span>
<span class="n">rtcount</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">rtcount</span><span class="o">.</span><span class="n">counter</span><span class="p">()</span>
<span class="n">rtcount</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
<span class="n">rtcount</span><span class="o">.</span><span class="n">deinit</span><span class="p">()</span>
</pre></div>
</div>
<p>Constants</p>
<dl class="data">
<dt id="machine.RTCounter.ONESHOT">
<code class="descclassname">RTCounter.</code><code class="descname">ONESHOT</code><a class="headerlink" href="#machine.RTCounter.ONESHOT" title="Permalink to this definition">¶</a></dt>
<dt id="machine.RTCounter.PERIODIC">
<code class="descclassname">RTCounter.</code><code class="descname">PERIODIC</code><a class="headerlink" href="#machine.RTCounter.PERIODIC" title="Permalink to this definition">¶</a></dt>
<dt id="machine.RTCounter.FREQUENCY">
<code class="descclassname">RTCounter.</code><code class="descname">FREQUENCY</code><a class="headerlink" href="#machine.RTCounter.FREQUENCY" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="deep-sleep-mode">
<h2>Deep-sleep mode<a class="headerlink" href="#deep-sleep-mode" title="Permalink to this headline">¶</a></h2>
<p>The following code can be used to sleep, wake and check the reset cause:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">machine</span>

<span class="c1"># check if the device woke from a deep sleep</span>
<span class="k">if</span> <span class="n">machine</span><span class="o">.</span><span class="n">reset_cause</span><span class="p">()</span> <span class="o">==</span> <span class="n">machine</span><span class="o">.</span><span class="n">DEEPSLEEP_RESET</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;woke from a deep sleep&#39;</span><span class="p">)</span>

<span class="c1"># put the device to sleep</span>
<span class="n">machine</span><span class="o">.</span><span class="n">deepsleep</span><span class="p">()</span>
</pre></div>
</div>
<p>Notes:</p>
<ul class="simple">
<li>Calling <code class="docutils literal notranslate"><span class="pre">deepsleep()</span></code> without an argument will put the device to sleep
indefinitely</li>
<li>A software reset does not change the reset cause</li>
</ul>
</div>
<div class="section" id="temp">
<h2>Temp<a class="headerlink" href="#temp" title="Permalink to this headline">¶</a></h2>
<p>The following code can be used to read temperature from on-soc:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">machine</span>

<span class="n">temp</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">Temp</span><span class="p">()</span>

<span class="n">temp</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="module-machine.UART">
<span id="uart"></span><h2>UART<a class="headerlink" href="#module-machine.UART" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">UART</span></code> module lets you talk to a device connected to your board using
a serial interface.</p>
<p>Functions</p>
<dl class="method">
<dt id="machine.UART.UART">
<code class="descclassname">machine.UART.</code><code class="descname">UART</code><span class="sig-paren">(</span><em>id=0</em>, <em>baudrate=115200</em><span class="sig-paren">)</span><a class="headerlink" href="#machine.UART.UART" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize serial communication with the specified parameters on the
specified <code class="docutils literal notranslate"><span class="pre">tx</span></code> and <code class="docutils literal notranslate"><span class="pre">rx</span></code> pins. Note that for correct communication, the parameters
have to be the same on both communicating devices.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Initializing the UART on external pins will cause the Python console on
USB to become unaccessible, as it uses the same hardware. To bring the
console back you must reinitialize the UART without passing anything for
<code class="docutils literal notranslate"><span class="pre">tx</span></code> or <code class="docutils literal notranslate"><span class="pre">rx</span></code> (or passing <code class="docutils literal notranslate"><span class="pre">None</span></code> to these arguments).  This means
that calling <code class="docutils literal notranslate"><span class="pre">uart.init(115200)</span></code> is enough to restore the Python console.</p>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">baudrate</span></code> defines the speed of communication. Common baud
rates include:</p>
<blockquote>
<div><ul class="simple">
<li>9600</li>
<li>14400</li>
<li>19200</li>
<li>28800</li>
<li>38400</li>
<li>57600</li>
<li>115200</li>
</ul>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">bits</span></code> defines the size of bytes being transmitted, and the board
only supports 8. The <code class="docutils literal notranslate"><span class="pre">parity</span></code> parameter defines how parity is checked,
and it can be <code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">microbit.uart.ODD</span></code> or <code class="docutils literal notranslate"><span class="pre">microbit.uart.EVEN</span></code>.
The <code class="docutils literal notranslate"><span class="pre">stop</span></code> parameter tells the number of stop bits, and has to be 1 for
this board.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">tx</span></code> and <code class="docutils literal notranslate"><span class="pre">rx</span></code> are not specified then the internal USB-UART TX/RX pins
are used which connect to the USB serial converter on the micro:bit, thus
connecting the UART to your PC.  You can specify any other pins you want by
passing the desired pin objects to the <code class="docutils literal notranslate"><span class="pre">tx</span></code> and <code class="docutils literal notranslate"><span class="pre">rx</span></code> parameters.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When connecting the device, make sure you “cross” the wires – the TX
pin on your board needs to be connected with the RX pin on the device,
and the RX pin – with the TX pin on the device. Also make sure the
ground pins of both devices are connected.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="machine.UART.uart.read">
<code class="descclassname">uart.</code><code class="descname">read</code><span class="sig-paren">(</span><span class="optional">[</span><em>nbytes</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#machine.UART.uart.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Read bytes.  If <code class="docutils literal notranslate"><span class="pre">nbytes</span></code> is specified then read at most that many
bytes, otherwise read as many bytes as possible.</p>
<p>Return value: a bytes object or <code class="docutils literal notranslate"><span class="pre">None</span></code> on timeout.</p>
<p>A bytes object contains a sequence of bytes. Because
<a class="reference external" href="https://en.wikipedia.org/wiki/ASCII">ASCII</a> characters can fit in
single bytes this type of object is often used to represent simple text
and offers methods to manipulate it as such, e.g. you can display the text
using the <code class="docutils literal notranslate"><span class="pre">print()</span></code> function.</p>
<p>You can also convert this object into a string object, and if there are
non-ASCII characters present the encoding can be specified:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">msg_bytes</span> <span class="o">=</span> <span class="n">uart</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="n">msg_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s1">&#39;UTF-8&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The timeout for all UART reads depends on the baudrate and is otherwise
not changeable via Python. The timeout, in milliseconds, is given by:
<code class="docutils literal notranslate"><span class="pre">microbit_uart_timeout_char</span> <span class="pre">=</span> <span class="pre">13000</span> <span class="pre">/</span> <span class="pre">baudrate</span> <span class="pre">+</span> <span class="pre">1</span></code></p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The internal UART RX buffer is 64 bytes, so make sure data is read
before the buffer is full or some of the data might be lost.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Receiving <code class="docutils literal notranslate"><span class="pre">0x03</span></code> will stop your program by raising a Keyboard
Interrupt. You can enable or disable this using
<a class="reference internal" href="../library/micropython.html#micropython.kbd_intr" title="micropython.kbd_intr"><code class="xref py py-func docutils literal notranslate"><span class="pre">micropython.kbd_intr()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="machine.UART.uart.readinto">
<code class="descclassname">uart.</code><code class="descname">readinto</code><span class="sig-paren">(</span><em>buf</em><span class="optional">[</span>, <em>nbytes</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#machine.UART.uart.readinto" title="Permalink to this definition">¶</a></dt>
<dd><p>Read bytes into the <code class="docutils literal notranslate"><span class="pre">buf</span></code>.  If <code class="docutils literal notranslate"><span class="pre">nbytes</span></code> is specified then read at most
that many bytes.  Otherwise, read at most <code class="docutils literal notranslate"><span class="pre">len(buf)</span></code> bytes.</p>
<p>Return value: number of bytes read and stored into <code class="docutils literal notranslate"><span class="pre">buf</span></code> or <code class="docutils literal notranslate"><span class="pre">None</span></code> on
timeout.</p>
</dd></dl>

<dl class="method">
<dt id="machine.UART.uart.readline">
<code class="descclassname">uart.</code><code class="descname">readline</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#machine.UART.uart.readline" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a line, ending in a newline character.</p>
<p>Return value: the line read or <code class="docutils literal notranslate"><span class="pre">None</span></code> on timeout. The newline character is
included in the returned bytes.</p>
</dd></dl>

<dl class="method">
<dt id="machine.UART.uart.readchar">
<code class="descclassname">uart.</code><code class="descname">readchar</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#machine.UART.uart.readchar" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a char.</p>
<p>Return value: the char read or <code class="docutils literal notranslate"><span class="pre">None</span></code> on timeout.</p>
</dd></dl>

<dl class="method">
<dt id="machine.UART.uart.writechar">
<code class="descclassname">uart.</code><code class="descname">writechar</code><span class="sig-paren">(</span><em>buf</em><span class="sig-paren">)</span><a class="headerlink" href="#machine.UART.uart.writechar" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a ASCII char number to the bus:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">uart</span><span class="o">.</span><span class="n">writechar</span><span class="p">(</span><span class="mi">31</span><span class="p">)</span>  <span class="c1">#write &#39;!&#39;</span>
</pre></div>
</div>
</dd></dl>

<p>See the MicroPython forum for other community-supported alternatives
to transfer files to an nRF52832 board.</p>
</div>
<div class="section" id="example">
<h2>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h2>
<dl class="method">
<dt id="machine.UART.mountsd.py">
<code class="descclassname">mountsd.</code><code class="descname">py</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#machine.UART.mountsd.py" title="Permalink to this definition">¶</a></dt>
<dd><p>Example for nrf52832 to show how mount and list a sdcard connected over SPI:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>Example for pca10040 / nrf52832 to show how mount
and list a sdcard connected over SPI.</p>
<dl class="docutils">
<dt>Direct wireing on SD card (SPI):</dt>
<dd><blockquote class="first">
<div></div></blockquote>
<div class="last line-block">
<div class="line-block">
<div class="line"></div>
</div>
<div class="line">9.      | NC    | </div>
<div class="line">1.      | ~CS   | |</div>
<div class="line">2.      | MOSI  | |</div>
<div class="line">3.      | GND   | |</div>
<div class="line">4.      | VCC3.3| |</div>
<div class="line">5.      | SCK   | |</div>
<div class="line">6.      | GND   | |</div>
<div class="line">7.      | MISO  | |</div>
<div class="line">8.      | NC    | |</div>
<div class="line-block">
<div class="line"><a href="#id1"><span class="problematic" id="id2">|</span></a></div>
</div>
</div>
</dd>
</dl>
<p>“”“</p>
<p>import os
from machine import SPI, Pin
from sdcard import SDCard</p>
<dl class="docutils">
<dt>def mnt():</dt>
<dd>cs = Pin(“P11”, mode=Pin.OUT)
sd = SDCard(SPI(0), cs)
os.mount(sd, ‘/’)</dd>
<dt>def list():</dt>
<dd>files = os.listdir()
print(files)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="machine.UART.musictest.py">
<code class="descclassname">musictest.</code><code class="descname">py</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#machine.UART.musictest.py" title="Permalink to this definition">¶</a></dt>
<dd><p>Example for nrf52832 to usage where “P3” is the Buzzer pin:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>Example usage where “P3” is the Buzzer pin.</p>
<p>from musictest import play
play(“P3”)</p>
<p>“”“</p>
<p>from machine import Pin
import music</p>
<dl class="docutils">
<dt>def play(pin_str):</dt>
<dd>p = Pin(pin_str, mode=Pin.OUT)
music.play(music.PRELUDE, pin=p)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="machine.UART.nrf52_pwm.py">
<code class="descclassname">nrf52_pwm.</code><code class="descname">py</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#machine.UART.nrf52_pwm.py" title="Permalink to this definition">¶</a></dt>
<dd><p>Example for nrf52832 to out pwm:</p>
<p>import time
from machine import PWM, Pin</p>
<dl class="docutils">
<dt>def pulse():</dt>
<dd><dl class="first last docutils">
<dt>for i in range(0, 101):</dt>
<dd>p = PWM(0, Pin(“P17”, mode=Pin.OUT), freq=PWM.FREQ_16MHZ, duty=i, period=16000)
p.init()
time.sleep_ms(10)
p.deinit()</dd>
<dt>for i in range(0, 101):</dt>
<dd>p = PWM(0, Pin(“P17”, mode=Pin.OUT), freq=PWM.FREQ_16MHZ, duty=100-i, period=16000)
p.init()
time.sleep_ms(10)
p.deinit()</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="machine.UART.nrf52_servo.py">
<code class="descclassname">nrf52_servo.</code><code class="descname">py</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#machine.UART.nrf52_servo.py" title="Permalink to this definition">¶</a></dt>
<dd><p>Example for nrf52832 to driver servo:</p>
<p>import time
from machine import PWM, Pin</p>
<dl class="docutils">
<dt>class Servo():</dt>
<dd><dl class="first last docutils">
<dt>def __init__(self, pin_name=”“):</dt>
<dd><dl class="first last docutils">
<dt>if pin_name:</dt>
<dd>self.pin = Pin(pin_name, mode=Pin.OUT, pull=Pin.PULL_DOWN)</dd>
<dt>else:</dt>
<dd>self.pin = Pin(“P17”, mode=Pin.OUT, pull=Pin.PULL_DOWN)</dd>
</dl>
</dd>
<dt>def left(self):</dt>
<dd>p = PWM(0, self.pin, freq=PWM.FREQ_125KHZ, pulse_width=105, period=2500, mode=PWM.MODE_HIGH_LOW)
p.init()
time.sleep_ms(200)
p.deinit()</dd>
<dt>def center(self):</dt>
<dd>p = PWM(0, self.pin, freq=PWM.FREQ_125KHZ, pulse_width=188, period=2500, mode=PWM.MODE_HIGH_LOW)
p.init()
time.sleep_ms(200)
p.deinit()</dd>
<dt>def right(self):</dt>
<dd>p = PWM(0, self.pin, freq=PWM.FREQ_125KHZ, pulse_width=275, period=2500, mode=PWM.MODE_HIGH_LOW)
p.init()
time.sleep_ms(200)
p.deinit()</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="machine.UART.powerup.py">
<code class="descclassname">powerup.</code><code class="descname">py</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#machine.UART.powerup.py" title="Permalink to this definition">¶</a></dt>
<dd><p>Examples is written for nrf52832, pca10040 using s132 bluetooth stack:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># MicroPython controller for PowerUp 3.0 paper airplane</span>
<span class="c1"># https://www.poweruptoys.com/products/powerup-v3</span>
<span class="c1">#</span>
<span class="c1"># Examples is written for nrf52832, pca10040 using s132 bluetooth stack.</span>
<span class="c1">#</span>
<span class="c1"># Joystick shield pin mapping:</span>
<span class="c1">#  - analog stick x-direction - ADC0 - P0.02/&quot;P2&quot;</span>
<span class="c1">#  - buttons P0.13 - P0.16 / &quot;P13&quot;, &quot;P14&quot;, &quot;P15&quot;, &quot;P16&quot;</span>
<span class="c1">#</span>
<span class="c1"># Example usage:</span>
<span class="c1">#</span>
<span class="c1">#     from powerup import PowerUp3</span>
<span class="c1">#     p = PowerUp3()</span>
</pre></div>
</div>
<p>import time
from machine import ADC
from machine import Pin
from ubluepy import Peripheral, Scanner, constants</p>
<dl class="docutils">
<dt>def bytes_to_str(bytes):</dt>
<dd><p class="first">string = “”
for b in bytes:</p>
<blockquote>
<div>string += chr(b)</div></blockquote>
<p class="last">return string</p>
</dd>
<dt>def get_device_names(scan_entries):</dt>
<dd><p class="first">dev_names = []
for e in scan_entries:</p>
<blockquote>
<div><p>scan = e.getScanData()
if scan:</p>
<blockquote>
<div><dl class="docutils">
<dt>for s in scan:</dt>
<dd><dl class="first last docutils">
<dt>if s[0] == constants.ad_types.AD_TYPE_COMPLETE_LOCAL_NAME:</dt>
<dd>dev_names.append((e, bytes_to_str(s[2])))</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p class="last">return dev_names</p>
</dd>
<dt>def find_device_by_name(name):</dt>
<dd><p class="first">s = Scanner()
scan_res = s.scan(500)</p>
<p>device_names = get_device_names(scan_res)
for dev in device_names:</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>if name == dev[1]:</dt>
<dd>return dev[0]</dd>
</dl>
</div></blockquote>
</dd>
<dt>class PowerUp3:</dt>
<dd><dl class="first last docutils">
<dt>def __init__(self):</dt>
<dd><p class="first">self.x_adc = ADC(1)</p>
<p>self.btn_speed_up = Pin(“P13”, mode=Pin.IN, pull=Pin.PULL_UP)
self.btn_speed_down = Pin(“P15”, mode=Pin.IN, pull=Pin.PULL_UP)
self.btn_speed_full = Pin(“P14”, mode=Pin.IN, pull=Pin.PULL_UP)
self.btn_speed_off = Pin(“P16”, mode=Pin.IN, pull=Pin.PULL_UP)</p>
<p>self.x_mid = 0</p>
<p class="last">self.calibrate()
self.connect()
self.loop()</p>
</dd>
<dt>def read_stick_x(self):</dt>
<dd>return self.x_adc.value()</dd>
<dt>def button_speed_up(self):</dt>
<dd>return not bool(self.btn_speed_up.value())</dd>
<dt>def button_speed_down(self):</dt>
<dd>return not bool(self.btn_speed_down.value())</dd>
<dt>def button_speed_full(self):</dt>
<dd>return not bool(self.btn_speed_full.value())</dd>
<dt>def button_speed_off(self):</dt>
<dd>return not bool(self.btn_speed_off.value())</dd>
<dt>def calibrate(self):</dt>
<dd>self.x_mid = self.read_stick_x()</dd>
<dt>def __str__(self):</dt>
<dd>return “calibration x: %i, y: %i” % (self.x_mid)</dd>
<dt>def map_chars(self):</dt>
<dd><p class="first">s = self.p.getServices()</p>
<p>service_batt = s[3]
service_control = s[4]</p>
<p class="last">self.char_batt_lvl = service_batt.getCharacteristics()[0]
self.char_control_speed = service_control.getCharacteristics()[0]
self.char_control_angle = service_control.getCharacteristics()[2]</p>
</dd>
<dt>def battery_level(self):</dt>
<dd>return int(self.char_batt_lvl.read()[0])</dd>
<dt>def speed(self, new_speed=None):</dt>
<dd><dl class="first last docutils">
<dt>if new_speed == None:</dt>
<dd>return int(self.char_control_speed.read()[0])</dd>
<dt>else:</dt>
<dd>self.char_control_speed.write(bytearray([new_speed]))</dd>
</dl>
</dd>
<dt>def angle(self, new_angle=None):</dt>
<dd><dl class="first last docutils">
<dt>if new_angle == None:</dt>
<dd>return int(self.char_control_angle.read()[0])</dd>
<dt>else:</dt>
<dd>self.char_control_angle.write(bytearray([new_angle]))</dd>
</dl>
</dd>
<dt>def connect(self):</dt>
<dd><p class="first">dev = None</p>
<p># connect to the airplane
while not dev:</p>
<blockquote>
<div><p>dev = find_device_by_name(“TailorToys PowerUp”)
if dev:</p>
<blockquote>
<div>self.p = Peripheral()
self.p.connect(dev.addr())</div></blockquote>
</div></blockquote>
<p class="last"># locate interesting characteristics
self.map_chars()</p>
</dd>
<dt>def rudder_center(self):</dt>
<dd><dl class="first last docutils">
<dt>if self.old_angle != 0:</dt>
<dd>self.old_angle = 0
self.angle(0)</dd>
</dl>
</dd>
<dt>def rudder_left(self, angle):</dt>
<dd><p class="first">steps = (angle // self.interval_size_left)
new_angle = 60 - steps</p>
<dl class="last docutils">
<dt>if self.old_angle != new_angle:</dt>
<dd>self.angle(new_angle)
self.old_angle = new_angle</dd>
</dl>
</dd>
<dt>def rudder_right(self, angle):</dt>
<dd><p class="first">steps = (angle // self.interval_size_right)
new_angle = -steps</p>
<dl class="last docutils">
<dt>if self.old_angle != new_angle:</dt>
<dd>self.angle(new_angle)
self.old_angle = new_angle</dd>
</dl>
</dd>
<dt>def throttle(self, speed):</dt>
<dd><dl class="first last docutils">
<dt>if (speed &gt; 200):</dt>
<dd>speed = 200</dd>
<dt>elif (speed &lt; 0):</dt>
<dd>speed = 0</dd>
<dt>if self.old_speed != speed:</dt>
<dd>self.speed(speed)
self.old_speed = speed</dd>
</dl>
</dd>
<dt>def loop(self):</dt>
<dd><p class="first">adc_threshold = 10
right_threshold = self.x_mid + adc_threshold
left_threshold = self.x_mid - adc_threshold</p>
<p>self.interval_size_left = self.x_mid // 60
self.interval_size_right = (255 - self.x_mid) // 60</p>
<p>self.old_angle = 0
self.old_speed = 0</p>
<p>while True:</p>
<blockquote class="last">
<div><p>time.sleep_ms(100)</p>
<p># read out new angle
new_angle = self.read_stick_x()
if (new_angle &lt; 256):</p>
<blockquote>
<div><dl class="docutils">
<dt>if (new_angle &gt; right_threshold):</dt>
<dd>self.rudder_right(new_angle - self.x_mid)</dd>
<dt>elif (new_angle &lt; left_threshold):</dt>
<dd>self.rudder_left(new_angle)</dd>
<dt>else:</dt>
<dd>self.rudder_center()</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt># read out new speed</dt>
<dd>new_speed = self.old_speed</dd>
<dt>if self.button_speed_up():</dt>
<dd>new_speed += 25</dd>
<dt>elif self.button_speed_down():</dt>
<dd>new_speed -= 25</dd>
<dt>elif self.button_speed_full():</dt>
<dd>new_speed = 200</dd>
<dt>elif self.button_speed_off():</dt>
<dd>new_speed = 0</dd>
<dt>else:</dt>
<dd>pass</dd>
</dl>
<p>self.throttle(new_speed)</p>
<p>p = PWM(0, self.pin, freq=PWM.FREQ_125KHZ, pulse_width=275, period=2500, mode=PWM.MODE_HIGH_LOW)
p.init()
time.sleep_ms(200)
p.deinit()</p>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="machine.UART.ssd1306_oled.py">
<code class="descclassname">ssd1306_oled.</code><code class="descname">py</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#machine.UART.ssd1306_oled.py" title="Permalink to this definition">¶</a></dt>
<dd><p>Examples is written for nrf52832 driver ssd1306 oled displayer:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># NOTE: Modified version to align with implemented I2C API in nrf port.</span>
<span class="c1">#</span>
<span class="c1"># Examples usage of SSD1306_SPI on pca10040</span>
<span class="c1">#</span>
<span class="c1"># from machine import Pin, SPI</span>
<span class="c1"># from ssd1306 import SSD1306_SPI</span>
<span class="c1"># spi = SPI(0, baudrate=40000000)</span>
<span class="c1"># dc = Pin.board.PA11</span>
<span class="c1"># res = Pin.board.PA12</span>
<span class="c1"># cs = Pin.board.PA13</span>
<span class="c1"># disp = SSD1306_SPI(128, 64, spi, dc, res, cs)</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># Example usage of SSD1306_I2C on pca10040</span>
<span class="c1">#</span>
<span class="c1"># from machine import Pin, I2C</span>
<span class="c1"># from ssd1306_mod import SSD1306_I2C_Mod</span>
<span class="c1"># i2c = I2C(0, Pin(26), Pin(25))</span>
<span class="c1"># disp = SSD1306_I2C_Mod(128, 64, i2c)</span>
</pre></div>
</div>
<p>from ssd1306 import SSD1306_I2C</p>
<p>SET_COL_ADDR        = const(0x21)
SET_PAGE_ADDR       = const(0x22)</p>
<p>class SSD1306_I2C_Mod(SSD1306_I2C):</p>
<blockquote>
<div><dl class="docutils">
<dt>def show(self):</dt>
<dd><p class="first">x0 = 0
x1 = self.width - 1
if self.width == 64:</p>
<blockquote>
<div># displays with width of 64 pixels are shifted by 32
x0 += 32
x1 += 32</div></blockquote>
<p>self.write_cmd(SET_COL_ADDR)
self.write_cmd(x0)
self.write_cmd(x1)
self.write_cmd(SET_PAGE_ADDR)
self.write_cmd(0)
self.write_cmd(self.pages - 1)</p>
<p>chunk_size = 254 # 255, excluding opcode.
num_of_chunks = len(self.buffer) // chunk_size
leftover = len(self.buffer) - (num_of_chunks * chunk_size)</p>
<dl class="last docutils">
<dt>for i in range(0, num_of_chunks):</dt>
<dd>self.write_data(self.buffer[chunk_size*i:chunk_size*(i+1)])</dd>
<dt>if (leftover &gt; 0):</dt>
<dd>self.write_data(self.buffer[chunk_size * num_of_chunks:])</dd>
</dl>
</dd>
<dt>def write_data(self, buf):</dt>
<dd>buffer = bytearray([0x40]) + buf # Co=0, D/C#=1
self.i2c.writeto(self.addr, buffer)</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="machine.UART.ubluepy_eddystone.py">
<code class="descclassname">ubluepy_eddystone.</code><code class="descname">py</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#machine.UART.ubluepy_eddystone.py" title="Permalink to this definition">¶</a></dt>
<dd><p>Examples is written for nrf52832 ubluepy module API example:</p>
<p>from ubluepy import Peripheral, constants</p>
<p>BLE_GAP_ADV_FLAG_LE_GENERAL_DISC_MODE       = const(0x02)
BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED       = const(0x04)</p>
<p>BLE_GAP_ADV_FLAGS_LE_ONLY_GENERAL_DISC_MODE = const(BLE_GAP_ADV_FLAG_LE_GENERAL_DISC_MODE | BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED)</p>
<p>EDDYSTONE_FRAME_TYPE_URL                    = const(0x10)
EDDYSTONE_URL_PREFIX_HTTP_WWW               = const(0x00) # “<a class="reference external" href="http://www">http://www</a>”.
EDDYSTONE_URL_SUFFIX_DOT_COM                = const(0x01) # “.com”</p>
<dl class="docutils">
<dt>def string_to_binarray(text):</dt>
<dd><p class="first">b = bytearray([])
for c in text:</p>
<blockquote>
<div>b.append(ord(c))</div></blockquote>
<p class="last">return b</p>
</dd>
<dt>def gen_ad_type_content(ad_type, data):</dt>
<dd>b = bytearray(1)
b.append(ad_type)
b.extend(data)
b[0] = len(b) - 1
return b</dd>
<dt>def generate_eddystone_adv_packet(url):</dt>
<dd><p class="first"># flags
disc_mode = bytearray([BLE_GAP_ADV_FLAGS_LE_ONLY_GENERAL_DISC_MODE])
packet_flags = gen_ad_type_content(constants.ad_types.AD_TYPE_FLAGS, disc_mode)</p>
<p># 16-bit uuid
uuid = bytearray([0xAA, 0xFE])
packet_uuid16 = gen_ad_type_content(constants.ad_types.AD_TYPE_16BIT_SERVICE_UUID_COMPLETE, uuid)</p>
<p># eddystone data
rssi = 0xEE # -18 dB, approx signal strength at 0m.
eddystone_data = bytearray([])
eddystone_data.append(EDDYSTONE_FRAME_TYPE_URL)
eddystone_data.append(rssi)
eddystone_data.append(EDDYSTONE_URL_PREFIX_HTTP_WWW)
eddystone_data.extend(string_to_binarray(url))
eddystone_data.append(EDDYSTONE_URL_SUFFIX_DOT_COM)</p>
<p># service data
service_data = uuid + eddystone_data
packet_service_data = gen_ad_type_content(constants.ad_types.AD_TYPE_SERVICE_DATA, service_data)</p>
<p># generate advertisment packet
packet = bytearray([])
packet.extend(packet_flags)
packet.extend(packet_uuid16)
packet.extend(packet_service_data)</p>
<p class="last">return packet</p>
</dd>
<dt>def start():</dt>
<dd>adv_packet = generate_eddystone_adv_packet(“micropython”)
p = Peripheral()
p.advertise(data=adv_packet, connectable=False)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="descclassname">ubluepy_eddystone.</code><code class="descname">py</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Examples is written for nrf52832 ubluepy module scan example:</p>
<p>from ubluepy import Scanner, constants</p>
<dl class="docutils">
<dt>def bytes_to_str(bytes):</dt>
<dd><p class="first">string = “”
for b in bytes:</p>
<blockquote>
<div>string += chr(b)</div></blockquote>
<p class="last">return string</p>
</dd>
<dt>def get_device_names(scan_entries):</dt>
<dd><p class="first">dev_names = []
for e in scan_entries:</p>
<blockquote>
<div><p>scan = e.getScanData()
if scan:</p>
<blockquote>
<div><dl class="docutils">
<dt>for s in scan:</dt>
<dd><dl class="first last docutils">
<dt>if s[0] == constants.ad_types.AD_TYPE_COMPLETE_LOCAL_NAME:</dt>
<dd>dev_names.append((e, bytes_to_str(s[2])))</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p class="last">return dev_names</p>
</dd>
<dt>def find_device_by_name(name):</dt>
<dd><p class="first">s = Scanner()
scan_res = s.scan(100)</p>
<p>device_names = get_device_names(scan_res)
for dev in device_names:</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>if name == dev[1]:</dt>
<dd>return dev[0]</dd>
</dl>
</div></blockquote>
</dd>
</dl>
<p># &gt;&gt;&gt; res = find_device_by_name(“micr”)
# &gt;&gt;&gt; if res:
# …     print(“address:”, res.addr())
# …     print(“address type:”, res.addr_type())
# …     print(“rssi:”, res.rssi())
# …
# …
# …
# address: c2:73:61:89:24:45
# address type: 1
# rssi: -26</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descclassname">ubluepy_eddystone.</code><code class="descname">py</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Examples is written for nrf52832 ubluepy module temp example:</p>
<p>from board import LED
from machine import RTCounter, Temp
from ubluepy import Service, Characteristic, UUID, Peripheral, constants</p>
<dl class="docutils">
<dt>def event_handler(id, handle, data):</dt>
<dd><p class="first">global rtc
global periph
global serv_env_sense
global notif_enabled</p>
<dl class="last docutils">
<dt>if id == constants.EVT_GAP_CONNECTED:</dt>
<dd># indicated ‘connected’
LED(1).on()</dd>
<dt>elif id == constants.EVT_GAP_DISCONNECTED:</dt>
<dd># stop low power timer
rtc.stop()
# indicate ‘disconnected’
LED(1).off()
# restart advertisment
periph.advertise(device_name=”micr_temp”, services=[serv_env_sense])</dd>
<dt>elif id == constants.EVT_GATTS_WRITE:</dt>
<dd><p class="first"># write to this Characteristic is to CCCD
if int(data[0]) == 1:</p>
<blockquote>
<div>notif_enabled = True
# start low power timer
rtc.start()</div></blockquote>
<dl class="last docutils">
<dt>else:</dt>
<dd>notif_enabled = False
# stop low power timer
rtc.stop()</dd>
</dl>
</dd>
</dl>
</dd>
<dt>def send_temp(timer_id):</dt>
<dd><p class="first">global notif_enabled
global char_temp</p>
<dl class="last docutils">
<dt>if notif_enabled:</dt>
<dd># measure chip temperature
temp = Temp.read()
temp =  temp * 100
char_temp.write(bytearray([temp &amp; 0xFF, temp &gt;&gt; 8]))</dd>
</dl>
</dd>
</dl>
<p># start off with LED(1) off
LED(1).off()</p>
<p># use RTC1 as RTC0 is used by bluetooth stack
# set up RTC callback every 5 second
rtc = RTCounter(1, period=50, mode=RTCounter.PERIODIC, callback=send_temp)</p>
<p>notif_enabled = False</p>
<p>uuid_env_sense = UUID(“0x181A”) # Environmental Sensing service
uuid_temp = UUID(“0x2A6E”) # Temperature characteristic</p>
<p>serv_env_sense = Service(uuid_env_sense)</p>
<p>temp_props = Characteristic.PROP_NOTIFY | Characteristic.PROP_READ
temp_attrs = Characteristic.ATTR_CCCD
char_temp = Characteristic(uuid_temp, props = temp_props, attrs = temp_attrs)</p>
<p>serv_env_sense.addCharacteristic(char_temp)</p>
<p>periph = Peripheral()
periph.addService(serv_env_sense)
periph.setConnectionHandler(event_handler)
periph.advertise(device_name=”micr_temp”, services=[serv_env_sense])</p>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="general.html" class="btn btn-neutral float-right" title="General information about the nRF52832 port" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../wipy/tutorial/reset.html" class="btn btn-neutral" title="6. Reset and boot modes" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014-2019, Damien P. George, Paul Sokolovsky, and contributors
      Last updated on 19 Apr 2019.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book"> Versions and Downloads</span>
    latest
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions">
    <dl>
      <dt>Versions</dt>
      
        <dd><a href="//en/latest">latest</a></dd>
      
    </dl>
    <dl>
      <dt>Downloads</dt>
      
        <dd><a href="//en/latest/micropython-docs.pdf">PDF</a></dd>
      
    </dl>
    <hr/>
    <dl>
      <dt>External links</dt>
        <dd>
          <a href="https://www.micropython.org">micropython.org</a>
        </dd>
        <dd>
          <a href="https://github.com/micropython/micropython">GitHub</a>
        </dd>
    </dl>
  </div>
</div>

  

    
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'1.10',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../static/jquery.js"></script>
        <script type="text/javascript" src="../static/underscore.js"></script>
        <script type="text/javascript" src="../static/doctools.js"></script>
    

  

  <script type="text/javascript" src="../static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>